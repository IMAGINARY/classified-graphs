{"mappings":"YASA,SAASA,EAASC,GAChB,OAAOA,EAAEC,QAAO,SAACC,EAAKC,G,OAAQD,EAAMC,C,IAGtC,SAASC,EAAQC,GACf,OAAOA,EAAEC,M,CAGX,SAASC,EAAQF,GACf,OAAOA,EAAE,GAAGC,M,CAGd,SAASE,EAAYR,GAGnB,IAFA,IAAMS,EAAI,GAEDC,EAAI,EAAGA,EAAIV,EAAEM,OAAQI,GAAK,EACjCD,EAAEC,GAAKV,EAAEU,GAAGC,QAGd,OAAOF,C,CAGT,SAASG,EAAkBZ,GAGzB,IAFA,IAAMa,EAAIb,EAAEM,OAEHI,EAAI,EAAGA,EAAIG,EAAGH,GAAK,EAC1B,GAAIV,EAAEU,GAAGJ,SAAWO,EAAG,OAAO,EAGhC,OAAO,C,CAGT,SAASC,EAAQT,GACf,OAAO,SAACU,GAEN,IADA,IAAMC,EAAOT,EAAQF,GACZY,EAAI,EAAGA,EAAID,EAAMC,GAAK,EAC7B,GAAgB,IAAZZ,EAAEU,GAAGE,GAAU,OAAOA,EAE5B,OAAO,C,EAIX,SAASC,EAAMb,EAAec,EAAeC,GAK3C,IAJA,IAAMC,EAAOjB,EAAQgB,GAEfE,EAAQR,EAAQT,GAEbkB,EAAK,EAAGA,EAAKF,EAAME,GAAM,EAChC,IAAK,IAAIC,EAAK,EAAGA,EAAKH,EAAMG,GAAM,EAAG,CACnC,IAAMC,EAAIL,EAAEG,GAAIC,GAEhB,GAAIC,EAAG,CAEL,IAAMC,EAAKJ,EAAMC,GACXI,EAAKL,EAAME,GAGjB,GAAIL,EAAEO,GAAIC,KAAQF,EAEhB,OAAO,C,EAMf,OAAO,C,CAeT,SAASG,EACPC,EACAC,EACAX,EACAC,EACAf,EACA0B,EACAC,EACAC,GAEA,IAAMjB,EAAOT,EAAQF,GAErB,GAAIyB,IAAY1B,EAAQC,GAClBa,EAAMb,EAAGc,EAAGC,KACdW,EAAIG,KAAK1B,EAAYH,IAErB8B,QAAQC,IAAI,2BAET,CACL,IAAMC,EAAK7B,EAAYH,GAInB4B,GAwCR,SAAsB5B,EAAee,EAAeD,GAIlD,IAAK,IAAIT,EAAI,EAAGA,EAAIL,EAAEC,OAAQI,GAAK,EACjC,IAAK,IAAI4B,EAAI,EAAGA,EAAIjC,EAAEC,OAAQgC,GAAK,EAKjC,GAAgB,IAAZjC,EAAEK,GAAG4B,GAEP,IAAK,IAAIC,EAAI,EAAGA,EAAInB,EAAEd,OAAQiC,GAAK,EACjC,GAAgB,IAAZnB,EAAEV,GAAG6B,GAAU,CAOjB,IADA,IAAIC,GAAgB,EACXC,EAAI,EAAGA,EAAItB,EAAEb,OAAQmC,GAAK,EACjC,GAAgB,IAAZtB,EAAEmB,GAAGG,GAAU,CACjBD,GAAgB,EAChB,K,CAICA,IACHnC,EAAEK,GAAG4B,GAAK,E,EAlElBI,CAAaL,EAAIjB,EAAGD,GAItB,IAAK,IAAIF,EAAI,EAAGA,EAAID,EAAMC,GAAK,EAG7B,GAAwB,IAApBY,EAAaZ,IAA8B,IAAlBZ,EAAEyB,GAASb,GAAU,CAEhD,IAAK,IAAIP,EAAI,EAAGA,EAAIM,EAAMN,GAAK,EAE3B2B,EAAGP,GAASpB,GADVA,IAAMO,EACS,EAEA,EAKrBY,EAAaZ,GAAK,GAGN,OAARe,GAAgBD,EAAIzB,OAAS0B,IAC/BJ,EAAQC,EAAcC,EAAU,EAAGX,EAAGC,EAAGiB,EAAIN,EAAKC,EAAKC,GAIzDJ,EAAaZ,GAAK,C,GA8D1B,SAAS0B,EACPvB,EACAD,EACAJ,EACA6B,GAIA,OAFa7C,EAASqB,EAAEL,KACXhB,EAASoB,EAAEyB,G,CAI1B,SAASC,EACP1B,EACAC,EACA0B,GAEA,IAAMC,EAAQ3B,EAAEd,OACV0C,EAAQ7B,EAAEb,OAEhBwC,EAAcA,GAAeH,EAQ7B,IAJA,IAAMtC,EAAI,IAAI4C,MAAMF,GACjBG,KAAK,MACLC,KAAI,W,OAAM,IAAIF,MAAcD,GAAOE,KAAK,E,IAElCxC,EAAI,EAAGA,EAAIqC,EAAOrC,GAAK,EAC9B,IAAK,IAAI4B,EAAI,EAAGA,EAAIU,EAAOV,GAAK,EAC1BQ,EAAY1B,EAAGD,EAAGT,EAAG4B,KACvBjC,EAAEK,GAAG4B,GAAK,GAKhB,OAAOjC,C,CAiBT,SAAS+C,EACPjC,EACAC,EACAiC,EACAC,GAOA,IAAMN,EAAQ7B,EAAEb,OAKhB,GAAI0C,IAJU5B,EAAEd,OAIK,MAAO,GAG5B,GAAI+C,SAA2CA,GAAU,EAAG,MAAO,GAGnE,IAAKzC,EAAkBO,GAAI,OAAO,KAClC,IAAKP,EAAkBQ,GAAI,OAAO,KAGlCiC,EAASA,GAAU,KAEnB,IAAMhD,EAAIwC,EAAa1B,EAAGC,EAAGkC,GAEvBC,EAAU,GAEVC,EAAYC,YAAYC,MAE9B9B,EACE,IAAIqB,MAAMD,GAAOE,KAAK,GACtB,EACA/B,EACAC,EACAf,EACAkD,EACAF,GACA,GAGF,IAAMM,EAAUF,YAAYC,MAO5B,OAJAvB,QAAQC,IACN,iBAA2DwB,SAAxCD,EAAUH,GAAa,KAAMK,QAAQ,GAAG,aAGtDN,C,CC/STO,UAAY,SAAUC,GACpB,IAAMC,EAASZ,EAAuBW,EAAEE,KAAK,GAAIF,EAAEE,KAAK,GAAI,OAAGC,GAE/DC,YAAYH,E","sources":["src/ts/utils/subgraph-isomorphism.ts","src/ts/modes/sgiso_worker.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\n\n/*\nAdapted from https://github.com/sdiemert/subgraph-isomorphism/blob/master/index.js\n*/\n\n// import math from 'mathjs';\n// the package only used math.js for creating zeroes matrices. We eliminated the dependency.\n\nfunction arraySum(A: number[]): number {\n  return A.reduce((acc, val) => acc + val);\n}\n\nfunction numRows(M: number[][]): number {\n  return M.length;\n}\n\nfunction numCols(M: number[][]): number {\n  return M[0].length;\n}\n\nfunction array2DCopy(A: number[][]): number[][] {\n  const X = [];\n\n  for (let i = 0; i < A.length; i += 1) {\n    X[i] = A[i].slice();\n  }\n\n  return X;\n}\n\nfunction checkSquareMatrix(A: number[][]): boolean {\n  const s = A.length;\n\n  for (let i = 0; i < s; i += 1) {\n    if (A[i].length !== s) return false;\n  }\n\n  return true;\n}\n\nfunction mapPtoG(M: number[][]): (p: number) => number {\n  return (p) => {\n    const cols = numCols(M);\n    for (let c = 0; c < cols; c += 1) {\n      if (M[p][c] === 1) return c;\n    }\n    return -1; // This would be an error.\n  };\n}\n\nfunction isIso(M: number[][], G: number[][], P: number[][]): boolean {\n  const rows = numRows(P);\n\n  const morph = mapPtoG(M);\n\n  for (let r1 = 0; r1 < rows; r1 += 1) {\n    for (let r2 = 0; r2 < rows; r2 += 1) {\n      const d = P[r1][r2];\n      // adjacent in P\n      if (d) {\n        // find mapped nodes in G\n        const c1 = morph(r1);\n        const c2 = morph(r2);\n\n        // are they adjacent in G?\n        if (G[c1][c2] !== d) {\n          // no - not isomorphism\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n *\n * @param used_columns {number[]}\n * @param cur_row {number}\n * @param G {number[][]}\n * @param P {number[][]}\n * @param M {number[][]}\n * @param out {number[][][]}\n * @param num {number}\n * @param prune {boolean}\n */\n\nfunction recurse(\n  used_columns: number[],\n  cur_row: number,\n  G: number[][],\n  P: number[][],\n  M: number[][],\n  out: number[][][],\n  num: number | null,\n  prune: boolean,\n) {\n  const cols = numCols(M);\n\n  if (cur_row === numRows(M)) {\n    if (isIso(M, G, P)) {\n      out.push(array2DCopy(M));\n      // eslint-disable-next-line no-console\n      console.log('Found isomorphism!');\n    }\n  } else {\n    const Mp = array2DCopy(M);\n\n    // prune the proposed morphism to remove\n    // mappings that are obviously not possible.\n    if (prune) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      pruneOptions(Mp, P, G);\n    }\n\n    // for all unused columns c\n    for (let c = 0; c < cols; c += 1) {\n      // only explore if the nodes are candidates for matching and the\n      // column has not been set yet.\n      if (used_columns[c] === 0 && M[cur_row][c] === 1) {\n        // set column c in M' to 1 and other columns to 0\n        for (let i = 0; i < cols; i += 1) {\n          if (i === c) {\n            Mp[cur_row][i] = 1;\n          } else {\n            Mp[cur_row][i] = 0;\n          }\n        }\n\n        // mark c as used\n        used_columns[c] = 1;\n\n        // recurse, but only if they want to find more isomorphisms.\n        if (num === null || out.length < num) {\n          recurse(used_columns, cur_row + 1, G, P, Mp, out, num, prune);\n        }\n\n        // mark c as unused\n        used_columns[c] = 0;\n      }\n    }\n  }\n}\n\n/**\n *\n * @param M {number[][]} the proposed morphism between P and G\n * @param P {number[][]} the sub graph being matched\n * @param G {number[][]} the host graph\n */\nfunction pruneOptions(M: number[][], P: number[][], G: number[][]): void {\n  // M first dim (rows) are vertices of sub graph P\n  // M second dim (cols) are vertices of host graph G\n\n  for (let i = 0; i < M.length; i += 1) {\n    for (let j = 0; j < M.length; j += 1) {\n      // i - the vertex in P\n      // j - the vertex in G\n\n      // for all M[i][j] === 1\n      if (M[i][j] === 1) {\n        // for all neighbours x of vertex i in P\n        for (let x = 0; x < P.length; x += 1) {\n          if (P[i][x] === 1) {\n            // x is a vertex in P that is adjacent to i\n\n            // if there is no neighbour y of vertex j in G such\n            // that M[x][y] === 1, then set M[i][j] = 0\n\n            let hasNeighbourY = false;\n            for (let y = 0; y < G.length; y += 1) {\n              if (G[j][y] === 1) {\n                hasNeighbourY = true;\n                break;\n              }\n            }\n\n            if (!hasNeighbourY) {\n              M[i][j] = 0;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Determines if the nodes P[p] and G[g] are similar enough\n * to be candidates for an isomorphic mapping.\n *\n * This is the default implementation which uses the degree of\n * the nodes to determine similarity.\n *\n * @param P {number[][]}\n * @param G {number[][]}\n * @param p {number}\n * @param g {number}\n * @returns {boolean} true if they are similar enough, false otherwise.\n */\nfunction degreeCriteria(\n  P: number[][],\n  G: number[][],\n  p: number,\n  g: number,\n): boolean {\n  const pDeg = arraySum(P[p]);\n  const gDeg = arraySum(G[g]);\n  return pDeg <= gDeg;\n}\n\nfunction initMorphism(\n  G: number[][],\n  P: number[][],\n  criteriaFun?: (P: number[][], G: number[][], p: number, g: number) => boolean,\n) {\n  const Psize = P.length;\n  const Gsize = G.length;\n\n  criteriaFun = criteriaFun || degreeCriteria;\n\n  // M is |V_p| X |V_G| matrix (p rows, g cols)\n  //   let M = (math.zeros(P_size, G_size) as math.Matrix).toArray();\n  const M = new Array(Psize)\n    .fill(null)\n    .map(() => new Array<number>(Gsize).fill(0));\n\n  for (let i = 0; i < Psize; i += 1) {\n    for (let j = 0; j < Gsize; j += 1) {\n      if (criteriaFun(P, G, i, j)) {\n        M[i][j] = 1;\n      }\n    }\n  }\n\n  return M;\n}\n\n/**\n * Finds isomorphisms (mappings) of a subgraph in a host/mother graph.\n *\n * The subgraph algorithm is based on: http://adriann.github.io/Ullman%20subgraph%20isomorphism.html\n *\n * This algorithm is exponential and will be slow for large inputs.\n *\n * @param G {number[][]} Adjacency matrix of the host/mother graph in which to search for a match.\n * @param P {number[][]} Adjacency matrix of subgraph to search for\n * @param maxNum {number} [null] the maximum number isomorphisms to find, may return fewer if fewer are matched.\n * @param similarityCriteria {function} [degreeCriteria] a function used to determine if two nodes are similar enough to be candidates for matching in the resulting morphism.\n *\n * @returns {number[][][]} an array of morphism matrices (rows indices correspond to vertices of P, col indices correspond to vertices of G), null if error.\n */\nfunction getIsomorphicSubgraphs(\n  G: number[][],\n  P: number[][],\n  maxNum?: number | null,\n  similarityCriteria?: (\n    P: number[][],\n    G: number[][],\n    p: number,\n    g: number,\n  ) => boolean,\n) {\n  const Gsize = G.length;\n  const Psize = P.length;\n\n  // No match possible if |P| > |G|, not an error.\n  // if (Gsize < Psize) return [];\n  if (Gsize !== Psize) return [];\n\n  // They don't want a match, not an error.\n  if (maxNum !== null && maxNum !== undefined && maxNum <= 0) return [];\n\n  // Input adjacency matrices must be square, error if not\n  if (!checkSquareMatrix(G)) return null;\n  if (!checkSquareMatrix(P)) return null;\n\n  // set to null by default\n  maxNum = maxNum || null;\n\n  const M = initMorphism(G, P, similarityCriteria);\n\n  const results = [] as number[][][];\n\n  const startTime = performance.now();\n\n  recurse(\n    new Array(Gsize).fill(0) as number[], // math.zeros(1, G_size).toArray()[0],\n    0,\n    G,\n    P,\n    M,\n    results,\n    maxNum,\n    false,\n  );\n\n  const endTime = performance.now();\n\n  // eslint-disable-next-line no-console\n  console.log(\n    `Elapsed time: ${((endTime - startTime) / 1000).toFixed(2)} seconds`,\n  );\n\n  return results;\n}\n\nconst priv = {\n  initMorphism,\n  degreeCriteria,\n  recurse,\n  isIso,\n  mapPtoG,\n  arraySum,\n  checkSquareMatrix,\n};\n\nexport { getIsomorphicSubgraphs, priv };\n","/* eslint-disable */\nimport { getIsomorphicSubgraphs } from '../utils/subgraph-isomorphism';\n\nonmessage = function (e) {\n  const result = getIsomorphicSubgraphs(e.data[0], e.data[1], 1, undefined);\n\n  postMessage(result);\n};\n"],"names":["$71d642af5e20df2f$var$arraySum","A","reduce","acc","val","$71d642af5e20df2f$var$numRows","M","length","$71d642af5e20df2f$var$numCols","$71d642af5e20df2f$var$array2DCopy","X","i","slice","$71d642af5e20df2f$var$checkSquareMatrix","s","$71d642af5e20df2f$var$mapPtoG","p","cols","c","$71d642af5e20df2f$var$isIso","G","P","rows","morph","r1","r2","d","c1","c2","$71d642af5e20df2f$var$recurse","used_columns","cur_row","out","num","prune","push","console","log","Mp","j","x","hasNeighbourY","y","$71d642af5e20df2f$var$pruneOptions","$71d642af5e20df2f$var$degreeCriteria","g","$71d642af5e20df2f$var$initMorphism","criteriaFun","Psize","Gsize","Array","fill","map","$71d642af5e20df2f$export$97958de5fb350861","maxNum","similarityCriteria","results","startTime","performance","now","endTime","concat","toFixed","onmessage","e","result","data","undefined","postMessage"],"version":3,"file":"sgiso_worker.b7491b5b.js.map"}